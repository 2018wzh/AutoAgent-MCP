from typing import Union
from metachain.environment import LocalEnv, DockerEnv
from metachain.tools.meta.edit_tools import get_metachain_path
from metachain.tools.meta.edit_agents import list_agents
import json
from metachain import MetaChain
from metachain.types import Response
CODE_PREFIX = """\
import asyncio
import json
import argparse
from openai import AsyncOpenAI
from openai.types.chat import ChatCompletionMessageToolCall
from metachain.flow import default_drive, EventInput, ReturnBehavior
from metachain.flow.dynamic import goto_events, abort_this
import re
from metachain import MetaChain
from metachain.types import Response
from metachain.registry import register_workflow

def extract_answer(response: str, key: str):
    pattern = f"<{key}>(.*?)</{key}>"
    matches = re.findall(pattern, response)
    return matches[0] if len(matches) > 0 else None
"""

CODE_SUFFIX = r"""
def get_args(): 
    parser = argparse.ArgumentParser(description="running_workflow")
    parser.add_argument('--system_input', type=str, default=None)
    args = parser.parse_args()
    return args

if __name__ == "__main__":
    args = get_args()
"""

CODE_MAIN = """
    storage_results = dict({input_key} = args.system_input)
    asyncio.run(
        default_drive.invoke_event(
            on_start,
            global_ctx=storage_results,
        )
    )
    system_output = storage_results.get({output_key}, None)
    print("The system output is: " + system_output)
"""

EVENT_TEMPLATE_PREFIX = """\
@default_drive.{event_method}
async def {event_name}(event: EventInput, global_ctx):
    inputs = {inputs}
    input_dict = dict()
    for inp in inputs: 
        input_dict[inp["key"]] = global_ctx.get(inp["key"], None)
    
    messages = global_ctx.get('messages', [])
    task = {task}
    outputs = {output_list}
    agent = {agent_func_name}({model})
    
"""
EVENT_TEMPLATE_FIX = r"""
    input_str = []
    for key, value in input_dict.items():
        input_str.append(f"The {key.replace('_', ' ')} is {value}")
    input_str = "\n".join(input_str) + "\n"
    query = input_str + '.\nThe task is: ' + task + '.\n'
"""

# QUERY_TEMPLATE = """\
#     query = input_str + '.\\nThe task is: ' + task + '.\\n'
# """

START_EVENT_CODE = """\
@default_drive.make_event
async def on_start(event: EventInput, global_ctx):
    print("start the workflow:" + {workflow_name})
"""




IF_ELSE_SUFFIX = \
"""
You should follow the above instructions, and return the result in the following format:
"""

EVENT_TEMPLATE_SUFFIX = """\
    messages.append({
        "role": "user",
        "content": query
    })
    client = MetaChain()
    response: Response = await client.run_async(agent = agent, messages = messages, context_variables = global_ctx, debug = True)
    result = response.messages[-1]["content"]
    messages.extend(response.messages)
    global_ctx["messages"] = messages

    for output in outputs:
        ans = extract_answer(result, output["key"])
        if ans:
            if output["action"]["type"] == "RESULT":
                global_ctx[output["key"]] = ans
                return ans
            elif output["action"]["type"] == "ABORT":
                return abort_this()
            elif output["action"]["type"] == "GO_TO":
                return goto_events([output["action"]["value"]])
        elif len(outputs) == 1: 
            global_ctx[output["key"]] = result
            return result
    raise Exception("No valid answer found")
"""
def start_event_to_code(workflow_name: str) -> str:
    """
    Convert the start event to code.
    """
    return START_EVENT_CODE.format(workflow_name = repr(workflow_name))

def single_event_to_code(event: dict, agent_info_dict: dict) -> str:
    """
    Convert a single event to code.

    A event contains:
    - name (str): the name of the event
    - input (dict): the input to the event
    - task (str): the task to perform
    - outputs (list[dict]): the outputs to the event
    - listen (list[str]): the listen to the event
    - agent (dict): the agent to run
    """
    if event["listen"] == None or len(event["listen"]) == 0:
        event_method = "make_event"
    else: 
        event_method = "listen_group([{}])".format(", ".join(event["listen"]))
    inputs = event["inputs"]

    event_code = EVENT_TEMPLATE_PREFIX.format(event_method = event_method, event_name = event["name"], inputs = inputs, task = repr(event["task"]), output_list = event["outputs"], agent_mode_name = agent_info_dict[event["agent"]["name"]]["mode_name"], agent_func_name = agent_info_dict[event["agent"]["name"]]["func_name"], model = repr(event["agent"]["model"])) + EVENT_TEMPLATE_FIX

    if len(event["outputs"]) > 1: 
        condition_str = []
        for output in event["outputs"]:
            condition_str.append(f"If {output['condition']}, then encapsulate your final answer (answer ONLY) within <{output['key']}> and </{output['key']}>. ")
        query_suffix = "\n".join(condition_str)
        query_suffix = f"""
    query_suffix = {repr(IF_ELSE_SUFFIX)}
    query_suffix += {repr(query_suffix)}
    query += query_suffix
"""
        event_code += query_suffix + EVENT_TEMPLATE_SUFFIX
    else:
        event_code += EVENT_TEMPLATE_SUFFIX

    return event_code


def json_to_workflow_code(workflow_form: dict, context_variables: dict) -> str:
    system_input = workflow_form['system_input']
    system_output = workflow_form['system_output']
    code_env: Union[LocalEnv, DockerEnv] = context_variables.get("code_env", LocalEnv())
    try:
        path = get_metachain_path(code_env)
    except Exception as e:
        return "[ERROR] Failed to list agents. Error: " + str(e)
    
    agents_dir = path + "/metachain/agents"
    agent_list = list_agents(context_variables)
    if agent_list.startswith("[ERROR]"):
        return "Failed to list agents. Error: " + agent_list
    agent_dict = json.loads(agent_list)
    agent_info_dict = {}
    workflow_name = workflow_form["name"]
    for a in workflow_form["agents"]:
        agent_info_dict[a["name"]] = {"name": a["name"], "func_name": agent_dict[a["name"]]["func_name"], "mode_name": a["name"].replace(" ", "_").lower()}

    import_agent_str = ""
    for ainfo in agent_info_dict.values():
        import_agent_str += f"""
from metachain.agents import {ainfo['func_name']}
"""
    events = workflow_form["events"]
    events_code = CODE_PREFIX + import_agent_str
    for event in events:
        if event["name"] == "on_start":
            events_code += start_event_to_code(workflow_name)
        else:
            events_code += single_event_to_code(event, agent_info_dict)
    
    events_code += CODE_SUFFIX

    events_code += CODE_MAIN.format(input_key = system_input["key"], output_key = repr(system_output["key"]))

    with open("math_majority_voting.py", "w") as f:
        f.write(events_code)

def create_workflow(workflow_form: dict, context_variables: dict) -> str:
    pass

def run_workflow(workflow_name: str, context_variables: dict) -> str:
    pass


if __name__ == "__main__":
    workflow_form = json.load(open("metachain/agents/meta_agent/workflow_form/math_majority_voting.json", "r"))
    json_to_workflow_code(workflow_form, {})